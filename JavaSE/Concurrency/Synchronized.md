# `Synchronized`关键字
Java中的每个对象都有一个与之相关联的`monitor`，线程可以其上进行加锁或释放已获得的锁，任何时候只有一个线程能够获得这个锁。

Java提供了一种内置的锁机制来支持原子性：同步代码块(Synchronized Block)。同步代码块包括两个部分：作为锁的对象引用和由这个锁保护的代码块。

用关键字`synchronized`修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的所就是方法调用所在的对象。
静态的`synchronized`方法以<u>`Class`对象</u>作为锁：
```Java
static synchronized void staticMethod() {
	// do something
}
```
以下是以`lock`对象为锁：
```Java
synchronized（lock）{
	// 访问或修改由所保护的共享状态
}
```
而以下是以调用同步方法的<u>实例本身</u>为锁：
```Java
synchronized void instanceMethod() {
	// do somehing ...
}
```

同步代码块是可重入的。

## Java对象头
HotSpot虚拟机对象的对象头部分包含两类信息：
* Mark Word。这一类用于存储对象自身的运行时数据，比如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，<u>在运行期间，Mark Work里面存储的数据会随着锁标志的变化而变化</u>。
* Klass Pointer。对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，Java通过这个指针确定对象是哪个类的实例；
此外，如果对象是一个Java数组，对象头中还必须有一块用于记录数组长度的数据，因为JVM可以通过普通Java对象的元数据信息确定Java对象的大小，但是数组的长度是不确定的。

## 锁的状态级升级过程
锁一共有4种状态，级别从低到高分别是：无锁、偏向锁、轻量级锁和重量级锁。<u>锁的状态只支持升级，不支持降级</u>。

以下是锁的四种状态下Mark Word的内容：

| 锁状态   | 存储内容                                            | 最后两位（锁标志） |
| -------- | --------------------------------------------------- | ------------------ |
| 无锁     | hashCode、GC分代年龄、是否偏向锁（0）               | 01                 |
| 偏向锁   | 偏向线程ID、偏向时间戳、GC分代年龄、是否偏向锁（1） | 01                 |
| 轻量级锁 | 指向栈中锁记录的指针                                | 00                 |
| 重量级锁 | 指向互斥量（重量级锁）的指针                        | 10                 |

### 无锁
不对资源进行锁定，所有的线程都能访问并修改共享资源，但每次只有一个线程能修改成功。

在无锁状态下，线程会不断尝试修改共享资源。如果没有冲突，就修改成功并退出，否则
继续循环尝试直到修改成功。

### 偏向锁
大多数情况下，锁不仅不存在竞争，而且总是被同一个线程多次获得。偏向锁就是指同一个同步代码块一直被一个线程访问，那么该线程就会自动能够获取锁，这能降低获取锁的代价。

当一个线程访问同步代码块并获取锁时，会在对象头和栈帧的锁记录里面存储偏向的线程ID，以后该线程在进入和退出同步代码块时不需要进行CAS操作来加锁和解锁，只需要简单的检测一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁，否者则需要再检测Mark Word中偏向锁的标识是否为1（如果未设置，则使用CAS竞争锁，否则尝试使用CAS将对象头的偏向锁指向当前线程）。

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其它线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销需要等到全局安全点（这个时间点上没有正在执行的字节码）上才能进行。它会先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定的状态。撤销偏向锁后恢复到无锁或轻量级锁状态。

### 轻量级锁
当偏向锁被其它线程访问时，偏向锁就会升级为轻量级锁，其它线程会通过自旋的方式尝试获取锁，不会阻塞。

当线程进入同步代码块时，若同步对象的锁状态为无锁状态，JVM会再当前线程的栈帧中建立一个名为Lock Record的空间，用于存储对象目前的Mark Word的副本，然后将对象头中的Mark Word复制进去。复制成功后，JVM会使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。如果更新成功，该线程就获得了锁，对象头中的Mark Word会被设置为 **`00`**，表示此对象处于轻量级锁状态。若更新失败，JVM会检查对象头的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有锁，就直接进入同步代码块继续执行，否则说明有多个线程在竞争该锁。

若当前只有一个等待线程，则该等待线程会以自旋的方式进行等待。当自旋超过一定次数，或者一个线程持有锁，一个线程在自旋，第三个线程又来访问时，轻量级锁会升级为重量级锁。

### 重量级锁
当锁升级为重量级锁时，Mark Word存储的时指向重量级锁的指针，等待的线程会进入阻塞状态。

### 总结
偏向锁通过比对Mark Word来解决加锁问题，避免CAS操作；轻量级锁通过CAS操作和自旋解决加锁问题，避免线程阻塞和唤醒带来的性能损耗；重量级锁阻塞拥有锁的线程以外的所有线程。

## 参考资料
1. 《Java并发编程的艺术》.
2. 美团技术团队[不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html).